# Отчет по лабораторной работе 0
# Решение алгоритмических задач. Введение в инструменты и критерии оценки.

**Семестр:** 3 курс 5 семестр
**Группа:** ПИЖ-б-о-23-2(1)
**Дисциплина:** Анализ сложности алгоритмов
**Студент:** Хизриев Магомед-Салах Алиевич

## Цель работы
Настроить рабочее окружение, освоить базовые операции ввода/вывода, написать и протестировать первую программу. Научиться оценивать сложность отдельных операций и всей программы, проводить эмпирические замеры времени выполнения и визуализировать результаты

## Практическая часть

### Выполненные задачи
- [ ] Задача 1: Считывает два целых числа, a и b, из стандартного потока ввода.
- [ ] Задача 2: Вычисляет их сумму.
- [ ] Задача 3: Выводит результат в стандартный поток вывода.

### Ключевые фрагменты кода

```PYTHON
# simple_sum_analysis.py

import timeit
import matplotlib.pyplot as plt
import random

# --- Базовая задача ---


def calculate_sum():
    """
    Считывает два целых числа, вычисляет их сумму и выводит результат.
    Сложность: O(1)
    """
    a = int(input("Введите первое число: "))   # O(1)
    b = int(input("Введите второе число: "))   # O(1)
    result = a + b                             # O(1)
    print("Результат:", result)                # O(1)
    # Общая сложность: O(1)


# calculate_sum()  # Раскомментируйте для проверки работы функции


# --- Усложнённая версия: измерение времени выполнения для операции сложения ---


def add_numbers(a, b):
    """
    Возвращает сумму двух чисел.
    Сложность: O(1)
    """
    return a + b


def measure_time(func, a, b):
    """
    Измеряет время выполнения функции (в миллисекундах).
    """
    start = timeit.default_timer()
    func(a, b)
    end = timeit.default_timer()
    return (end - start) * 1000  # перевод в миллисекунды


# --- Информация о тестовом окружении ---
pc_info = """
Сведения о компьютере:
- Процессор: Intel Core i5-12500H @ 2.50GHz
- ОЗУ: 32 GB DDR4
- ОС: Windows 11
- Python: 3.12
"""
print(pc_info)


# --- Проведение экспериментов ---
# Мы будем увеличивать количество пар чисел для суммирования,
# чтобы увидеть, как растёт общее время при постоянной сложности O(1) каждой операции.

sizes = [1000, 5000, 10000, 50000, 100000, 500000]
times = []

print("Замеры времени для операции сложения двух чисел (многократное выполнение):")
print("{:>10} {:>12} {:>15}".format("Количество", "Время (мс)", "Время/операцию (мкс)"))

for n in sizes:
    # Генерация случайных чисел
    data = [(random.randint(1, 1000), random.randint(1, 1000)) for _ in range(n)]

    # Замер времени (усреднение по 10 прогонкам)
    avg_time = timeit.timeit(lambda: [add_numbers(a, b) for a, b in data],
                             number=10) * 1000 / 10
    times.append(avg_time)

    time_per_op = (avg_time * 1000 / n) if n > 0 else 0  # мкс на операцию

    print("{:>10} {:>12.4f} {:>15.4f}".format(n, avg_time, time_per_op))


# --- Визуализация результатов ---
plt.figure(figsize=(10, 6))
plt.plot(sizes, times, 'go-', label='Реальное время выполнения')
plt.xlabel('Количество операций (N)')
plt.ylabel('Время (мс)')
plt.title('Зависимость времени от количества операций сложения\nОценка сложности: O(N)')
plt.grid(True, linestyle='--', linewidth=0.5)
plt.legend()
plt.savefig('./report/simple_sum_time_plot.png', dpi=300, bbox_inches='tight')
plt.show()


# --- Анализ результатов ---
print("\nВыводы:")
print("1. Теоретическая сложность операции сложения: O(1)")
print("2. При множественных вычислениях общая зависимость времени линейная — O(N).")
print("3. Среднее время одной операции ≈ {:.4f} мкс".format(time_per_op))


